---
layout: post
title: "ARC基础"
date: 2013-11-11 20:22
comments: true
categories: oc
---

在手工内存管理中，需要retain一个对象让其可用。

在ARC中只需让一个指针指向那个对象。有变量指针指向那个对象，那么它就会一直存在内存中。

当指针指向另外一个对象或不存在的时候，那个关联的对象才会被释放掉。

```objc
NSString *firstName = self.textField.text;
```

firstName变量为文本框中内容字符串对象的所有者

text属性也是所有者

![](http://cdn5.raywenderlich.com/wp-content/uploads/2011/10/Pointers2-500x265.png)

<!--more-->

当用户输入新的文字时

text-->新的

firstName-->旧的

![](http://cdn1.raywenderlich.com/wp-content/uploads/2011/10/Pointers3-500x235.png)

当firstName -->新值或者超出作用范围的时候，字符串对象才会被释放

![](http://cdn1.raywenderlich.com/wp-content/uploads/2011/10/Pointers4-500x198.png)

firstName和textFiled.text为strong的类型指针。默认所有变量都是strong指针。

```objc
__weak NSString *weakName = self.textFiled.text;
```

![](http://cdn2.raywenderlich.com/wp-content/uploads/2011/10/Pointers5-500x241.png)

weak指针类型不能成为所有者，当文本框的内容改变了，那么字符串对象就会被释放。

![](http://cdn2.raywenderlich.com/wp-content/uploads/2011/10/Pointers6-500x209.png)

weak大多在两个父子关系对象上比较有用。

父对象有个strong指针指向子对象，为了防止关系循环，子对象仅仅有一个weak指针指向父对象。

![](http://cdn5.raywenderlich.com/wp-content/uploads/2011/10/Pointers7-500x212.png)

__  ARC 在适当的位置处理了 retain 和 release，仍然存在一些情况，需要手动的把这些指针设置为 nil，不然应用将会耗尽可用内存。如果一直保持所有创建的对象都存活，那么 ARC 将不能释放他们。 因此，当创建一个新对象的时候，需要考虑谁拥有它，还有这个对象应该存活多久。 __

_________

* __ strong __ “retain” 的一个代号。会成为它所指对象的所有者。

* __ weak __ 弱引用指针。它指向的对象被销毁时，它会被自动的设置成 nil。

* __ unsafe_unretained __ 等同“assign” 。 

* __ copy __ 它创建一个对象的拷贝，并且创建一个强引用关系。

* __ assign __ 不允许在对象上用这个修饰符， 但仍然能在简单类型的值，比如 BOOL,int 和 float 中用到它。

_________

```objc
@property(nonatomic,strong,readonly)NSString *result;
```
    
__ 如果定义了一个属性，那么应该用 self.propName 的形式来访问它， 而不是通过后端的实例变量(除非是在 init 方法，或者自定义的 getter 和 setter 方法中)。 __

        
不用arc编译的加上-no-bojc-arc标签

_________

整理自：[raywenderlich](http://www.raywenderlich.com/5677/beginning-arc-in-ios-5-part-1)

其他学习ARC文章:

* [苹果官方文档](https://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html)

